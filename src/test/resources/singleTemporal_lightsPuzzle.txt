(with lights
(configure :bitwidth 4 :solver SAT4J :max-solutions 1 :verbosity 1 :skolem-depth 0 :sb 20 :core-gran 0 :core-minimization fast :log-trans 0 :min-trace-length 5 :max-trace-length 5)
(univ 21)
(ints [(-8 0)(-7 1)(-6 2)(-5 3)(-4 4)(-3 5)(-2 6)(-1 7)(0 8)(1 9)(2 10)(3 11)(4 12)(5 13)(6 14)(7 15)])
(r:Int [{(0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) (14) (15)} :: {(0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) (14) (15)}])
(r:Light [{(16) (17) (18) (19) (20)} :: {(16) (17) (18) (19) (20)}])
(x:Lit [none :: {(16) (17) (18) (19) (20)}])
(x:Unlit [none :: {(16) (17) (18) (19) (20)}])
(r:succ [{(0 1) (1 2) (2 3) (3 4) (4 5) (5 6) (6 7) (7 8) (8 9) (9 10) (10 11) (11 12) (12 13) (13 14) (14 15)} :: {(0 1) (1 2) (2 3) (3 4) (4 5) (5 6) (6 7) (7 8) (8 9) (9 10) (10 11) (11 12) (12 13) (13 14) (14 15)}])
(r:left [(-> none none) :: {(17 20) (18 19) (17 19) (19 20) (18 18) (17 18) (19 19) (20 20) (18 17) (18 16) (20 19) (17 17) (19 18) (17 16) (19 17) (20 18) (16 20) (19 16) (20 17) (16 19) (20 16) (16 18) (16 17) (16 16) (18 20)}])
(r:right [(-> none none) :: {(17 20) (18 19) (17 19) (19 20) (18 18) (17 18) (19 19) (20 20) (18 17) (18 16) (20 19) (17 17) (19 18) (17 16) (19 17) (20 18) (16 20) (19 16) (20 17) (16 19) (20 16) (16 18) (16 17) (16 16) (18 20)}])
(f:0 (all ([v:x1_all11779 : one r:Light ] [v:x2_all11780 : one r:Light ] ) (&& (in v:x2_all11780 (. v:x1_all11779 (^ r:left )))(in v:x2_all11780 (. v:x1_all11779 (^ r:right ))))))
(assert f:0)
(f:1 (= r:left (~ r:right )))
(assert f:1)
(f:2 true )
(assert f:2)
(f:3 (always (&& (|| (&& (&& (&& (= x:Lit r:Light )))(= x:Lit (prime x:Lit )))(&& (! (&& (&& (= x:Lit r:Light ))))(some ([v:l_some11781 : one r:Light ] ) (&& (&& (= (prime x:Lit )(+ (- x:Lit {([v:x_set11782 : (+ (+ v:l_some11781 (. v:l_some11781 r:left ))(. v:l_some11781 r:right ))]) (in v:x_set11782 x:Lit )}){([v:x_set11783 : (+ (+ v:l_some11781 (. v:l_some11781 r:left ))(. v:l_some11781 r:right ))]) (! (in v:x_set11783 x:Lit ))}))))))))))
(assert f:3)
(f:4 (eventually (&& (&& (= x:Lit r:Light )))))
(assert f:4)
(f:5 (always (in r:succ (-> r:Int r:Int))))
(assert f:5)
(f:6 (always (in r:left (-> r:Light r:Light ))))
(assert f:6)
(f:7 (always (in r:right (-> r:Light r:Light ))))
(assert f:7)
(f:8 (always (= r:Light (+ x:Lit x:Unlit ))))
(assert f:8)
(f:9 (always (no (& x:Lit x:Unlit ))))
(assert f:9)
(f:10 (always (all ([v:a_all11785 : one r:Light ] ) (one (. v:a_all11785 r:left )))))
(assert f:10)
(f:11 (always (all ([v:a_all11787 : one r:Light ] ) (one (. v:a_all11787 r:right )))))
(assert f:11))**EOI**
(with lights (solve first))**EOI**
(with lights (solve C))**EOI**
(with lights (solve P))**EOI**